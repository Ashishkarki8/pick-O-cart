
npm i passport passport-google-oauth20 express-session i installed
npm i @reduxjs/toolkit react-redux axios react-router-dom

aba sadcn ko lagi tailwind css ra sab configure garesi we create a file name

jsconfig.json
{
    
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "@/*": ["./src/*"]
      }
    }
  }
  
and in vite.config.jsconfigimport { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path'
import { fileURLToPath } from 'url'

// Fix for __dirname in ESM  
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})


after that 
npx shadcn@latest init

shadcn@2.1.8
Ok to proceed? (y) y

✔ Preflight checks.
✔ Verifying framework. Found Vite.
✔ Validating Tailwind CSS.
✔ Validating import alias.
√ Which style would you like to use? » Default
√ Which color would you like to use as the base color? » Slate
√ Would you like to use CSS variables for theming? ... no / yes
✔ Writing components.json.
✔ Checking registry.
✔ Updating tailwind.config.js
✔ Updating src\index.css
✔ Installing dependencies.
✔ Created 1 file:
  - src\lib\utils.js

  ani aba frontend bhitra components bhanni folder banauni rah yo code halni
  npx shadcn@latest add button







Yes, if your editor (like VSCode) is defaulting to CommonJS (require) imports when you press Ctrl + Space, you can configure it to use ES Modules (import/export) instead. Additionally, there are extensions and settings that can help enforce and fix import styles.

Steps to Fix Automatic Imports in VSCode
1. Ensure "type": "module" in package.json
First, confirm that you have set "type": "module" in your package.json file to enable ES Modules:

json
Copy code
{
  "type": "module"
}
This tells Node.js and VSCode that your project uses ES Modules syntax.

2. Check VSCode Settings
VSCode uses TypeScript's IntelliSense for suggestions, so configure it to prefer ES Modules.

Open Settings:

Go to File > Preferences > Settings (or press Ctrl + ,).
Search for Import Module:

Look for a setting called javascript.preferences.importModuleSpecifier.
Set it to non-relative or auto for clean, module-based imports.
Example in settings.json:

json
Copy code
"javascript.preferences.importModuleSpecifier": "non-relative",
"typescript.preferences.importModuleSpecifier": "non-relative"
Update Import Style: Ensure the following settings in settings.json:

json
Copy code
"javascript.format.enable": true,
"javascript.preferences.quoteStyle": "single",
"javascript.preferences.importModuleSpecifierEnding": "auto"
3. Extensions to Improve Imports
Here are some useful VSCode extensions to help with ES Modules imports:

ESLint
Ensures consistent code style, including import statements.

Automatically fixes require() to import using ESLint rules.

Installation:

Search for ESLint in the VSCode Extensions panel.
Configuration: Add the following ESLint rule in your .eslintrc file:   @ext:dbaeumer.vscode-eslint

json
Copy code
"rules": {
  "no-restricted-syntax": ["error", "CallExpression[callee.name='require']"]
}
This will warn you if you use require() instead of import.

Auto Import
Automatically adds ES Module imports when you type a function or variable name.

Installation:

Search for Auto Import by Steoates in the Extensions pan







code history

index.js


import cookieParser from "cookie-parser";
import cors from "cors";
import express from "express";
import appConfig from "./appConfig.js";
import connectDb from "./connectDb.js";
import { applyCorsAndSecurity } from "./corsConfig.js";
import authRouter from "./routes/auth/authRoutes.js";
const app = express();

// Apply security headers and CORS configuration
const corsMiddleware = cors(applyCorsAndSecurity(app));

// Apply middleware in the correct order
// 1. Security and CORS
app.use(corsMiddleware);
app.options('*', corsMiddleware); // Handle preflight requests

// 2. Body parsing middleware
app.use(express.json());
app.use(cookieParser());

// 3. Routes
app.use("/api/auth/", authRouter);

// Start the server
app.listen(appConfig.serverPort, () => {
    console.log(`Server is running on port ${appConfig.serverPort}`);
});

// Connect to the database
connectDb();









import appConfig from "./appConfig.js";

// Determine if the environment is development
const isDevelopment = appConfig.nodeEnv === "development";

// CORS options
const corsOptions = {
    origin: (origin, callback) => {
        const allowedOrigins = [
            appConfig.frontendURL,
            "http://127.0.0.1:5173",
        ];

        if (isDevelopment) {
            // Allow requests with no origin (e.g., mobile apps, CLI tools)
            if (!origin) {
                return callback(null, true);
            }

            // Check if the origin is allowed
            if (allowedOrigins.includes(origin)) {
                return callback(null, true);
            }
        } else {
            // In production, perform strict origin checking
            if (!origin || allowedOrigins.includes(origin)) {
                return callback(null, true);
            }
        }

        callback(new Error("Not allowed by CORS"));
    },

    // Allowed HTTP methods
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],

    // Allowed headers
    allowedHeaders: [
        "Content-Type",
        "Authorization",
        "X-Requested-With",
        "Accept",
        "Origin",
        "Cache-Control",
    ],

    // Exposed headers (accessible to client)
    exposedHeaders: [
        "Content-Length",
        "X-RateLimit-Limit",
        "X-RateLimit-Remaining",
    ],

    // Allow credentials (cookies, authorization headers)
    credentials: true,

    // Cache preflight requests
    maxAge: isDevelopment ? 86400 : 7200, // 24 hours in dev, 2 hours in prod

    // Additional security options
    preflightContinue: false,
    optionsSuccessStatus: 204,
};

// Helper function to apply CORS and security headers
export const applyCorsAndSecurity = (app) => {
    app.use((req, res, next) => {
        // Security headers
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("X-Frame-Options", "DENY");
        res.setHeader("X-XSS-Protection", "1; mode=block");

        if (!isDevelopment) {
            res.setHeader(
                "Strict-Transport-Security",
                "max-age=31536000; includeSubDomains"
            );
        }

        next();
    });

    return corsOptions;
};

export default corsOptions;






authMiddleware
 inside login
 const { error, value } = loginValidator.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        errors: error.details.map((detail) => ({
          field: detail.path.join("."),
          message: detail.message,
        })),
      });
    }
    const { email, password } = value;
    const checkUser = await User.findOne({ email });


 while cookie
  const token = jwt.sign(
      {
        id: checkUser.id,
        role: checkUser.role,
        version:
          checkUser.tokenVersion /* Add token version for invalidation */ /* email: checkUser.email */,
      },
      appConfig.userSecretKey,
      {
        subject: "accessApi",
        expiresIn: appConfig.jwtExpirationTime,
        algorithm: "HS256",
      }
    );
    //  console.log(token);
    res.cookie("token", token, {
        httpOnly: true,
        secure: appConfig.nodeEnv === "production",
        sameSite: "lax",
        maxAge: parseInt(appConfig.jwtExpirationTime) * 1000, // Convert to milliseconds
        path: "/",
        domain: process.env.COOKIE_DOMAIN || undefined,
      })
      .json({
        //secure: false should be true later andConsider adding SameSite: 'Strict' or SameSite: 'Lax' for additional protection against CSRF.
        success: true,
        message: "Login succesfull",
        user: {
          // email: checkUser.email,  frontend lai email chaidaina tesailey napathjako
          role: checkUser.role,
          id: checkUser.id,
        },
      });
 res.cookie("token", token, {
        httpOnly: true,
        secure: appConfig.nodeEnv === "production",
        sameSite: "lax",
        maxAge: parseInt(appConfig.jwtExpirationTime) * 1000, // Convert to milliseconds
        path: "/",
        domain: process.env.COOKIE_DOMAIN || undefined,
      })

login validator

import Joi from 'joi';

// Joi schema for login
const loginValidator = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } }) // Option to disable TLD validation if needed
    .required()
    .messages({
      'string.email': 'Email must be a valid email address.',
      'any.required': 'Email is required.',
    }),
  password: Joi.string()
    .min(8) // Minimum 8 characters for better security
    .required()
    .messages({
      'string.min': 'Password must be at least 8 characters.',
      'any.required': 'Password is required.',
    }),
});

export default loginValidator;






//appConfig
import dotenv from "dotenv";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";

// Get the current directory of the module (similar to __dirname in CommonJS)
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Resolve the absolute path to the .env file
dotenv.config({ path: resolve(__dirname, '../.env') });

const appConfig = {
    mongoURL: process.env.MONGO_URL,
    serverPort: process.env.SERVER_PORT,
    frontendURL: process.env.FRONTEND_URL,
    userSecretKey: process.env.USER_SECRET_KEY,
    adminSecretKey: process.env.ADMIN_SECRET_KEY,
    jwtExpirationTime: process.env.JWT_EXPIRATION_TIME,
    nodeEnv: process.env.NODE_ENV,
};


export default appConfig;









auth authSliceimport appConfig from "@/appConfig";
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import axios from "axios";

// Action Types
const AUTH_REGISTER = "/auth/register";
const AUTH_LOGIN = "/auth/login";
const AUTH_CHECK_TOKEN = "/auth/check-auth";
const AUTH_LOGOUT = "/auth/logout";
const AUTH_REFRESH = "/auth/refresh";

// Axios instance with defaults
const api = axios.create({
  baseURL: `${appConfig.frontendApiURL}/api`,
  withCredentials: true,
  headers: {
    "Content-Type": "application/json",
  },
});

// Enhanced error parsing
const parseApiError = (error) => ({
  message: error.response?.data?.message || "An unexpected error occurred",
  status: error.response?.status || 500,
  details: error.response?.data?.details || null,
  code: error.response?.data?.code || 'UNKNOWN_ERROR'
});

// Initial state with session management
const initialState = {
  user: null,
  isAuthenticated: false,
  isLoading: true,
  error: null,
  isInitialized: false,
  sessionExpiry: null,    // New: Track token expiration
  lastActivity: null,     // New: Track user activity
  tokenVersion: null      // New: Track token version
};

// Register user
export const registerUser = createAsyncThunk(
  AUTH_REGISTER,
  async (formData, { rejectWithValue }) => {
    try {
      const response = await api.post("/auth/register", formData);
      return response.data;
    } catch (error) {
      return rejectWithValue(parseApiError(error));
    }
  }
);

// Login user with enhanced session handling
export const loginUser = createAsyncThunk(
  AUTH_LOGIN,
  async (formData, { rejectWithValue }) => {
    try {
      const response = await api.post("/auth/login", formData);
      // Extract session information from response headers
      const sessionExpiry = response.headers['x-session-expiry'];
      return {
        ...response.data,
        sessionExpiry: sessionExpiry ? new Date(sessionExpiry).getTime() : null
      };
    } catch (error) {
      return rejectWithValue(parseApiError(error));
    }
  }
);

// Enhanced auth check with automatic refresh
export const checkAuth = createAsyncThunk(
  AUTH_CHECK_TOKEN,
  async (_, { rejectWithValue, dispatch }) => {
    try {
      const response = await api.get("/auth/check-auth", {
        headers: {
          "Cache-Control": "no-store, no-cache, must-revalidate, proxy-revalidate",
        },
      });

      // Check if token needs refresh (e.g., if less than 5 minutes remaining)
      const sessionExpiry = response.headers['x-session-expiry'];
      if (sessionExpiry) {
        const expiryTime = new Date(sessionExpiry).getTime();
        if (expiryTime - Date.now() < 5 * 60 * 1000) {
          dispatch(refreshToken());
        }
      }

      return {
        ...response.data,
        sessionExpiry: sessionExpiry ? new Date(sessionExpiry).getTime() : null
      };
    } catch (error) {
      if (error.response?.status === 401) {
        return { user: null, sessionExpiry: null };
      }
      return rejectWithValue(parseApiError(error));
    }
  }
);

// New: Logout action
export const logoutUser = createAsyncThunk(
  AUTH_LOGOUT,
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.post("/auth/logout");
      return response.data;
    } catch (error) {
      return rejectWithValue(parseApiError(error));
    }
  }
);

// New: Refresh token
export const refreshToken = createAsyncThunk(
  AUTH_REFRESH,
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.post("/auth/refresh");
      return {
        ...response.data,
        sessionExpiry: response.headers['x-session-expiry']
          ? new Date(response.headers['x-session-expiry']).getTime()
          : null
      };
    } catch (error) {
      return rejectWithValue(parseApiError(error));
    }
  }
);

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    setUser: (state, action) => {
      state.user = action.payload;
      state.isAuthenticated = true;
      state.isLoading = false;
      state.isInitialized = true;
      state.error = null;
      state.lastActivity = Date.now();
    },
    clearError: (state) => {
      state.error = null;
    },
    updateLastActivity: (state) => {
      state.lastActivity = Date.now();
    },
  },
  extraReducers: (builder) => {
    builder
      // Register cases
      .addCase(registerUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(registerUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.isInitialized = true;
        state.user = action.payload.user || null;
        state.isAuthenticated = true;
        state.sessionExpiry = action.payload.sessionExpiry;
        state.tokenVersion = action.payload.tokenVersion;
        state.lastActivity = Date.now();
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload.message;
      })

      // Login cases
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.isInitialized = true;
        if (action.payload?.success) {
          state.user = action.payload.user;
          state.isAuthenticated = true;
          state.sessionExpiry = action.payload.sessionExpiry;
          state.tokenVersion = action.payload.tokenVersion;
          state.lastActivity = Date.now();
        } else {
          state.error = action.payload?.message || "Login failed.";
        }
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload.message;
      })

      // Check auth cases
      .addCase(checkAuth.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(checkAuth.fulfilled, (state, action) => {
        state.isLoading = false;
        state.isInitialized = true;
        if (action.payload?.success) {
          state.user = action.payload.user;
          state.isAuthenticated = true;
          state.sessionExpiry = action.payload.sessionExpiry;
          state.tokenVersion = action.payload.tokenVersion;
          state.lastActivity = Date.now();
        } else {
          state.user = null;
          state.isAuthenticated = false;
          state.sessionExpiry = null;
          state.tokenVersion = null;
        }
      })
      .addCase(checkAuth.rejected, (state, action) => {
        state.isLoading = false;
        state.isInitialized = true;
        state.user = null;
        state.isAuthenticated = false;
        state.error = action.payload?.message;
        state.sessionExpiry = null;
        state.tokenVersion = null;
      })

      // Logout cases
      .addCase(logoutUser.fulfilled, (state) => {
        state.user = null;
        state.isAuthenticated = false;
        state.sessionExpiry = null;
        state.tokenVersion = null;
        state.error = null;
        state.lastActivity = null;
      })
      .addCase(logoutUser.rejected, (state, action) => {
        state.error = action.payload.message;
      })

      // Refresh token cases
      .addCase(refreshToken.fulfilled, (state, action) => {
        if (action.payload?.success) {
          state.sessionExpiry = action.payload.sessionExpiry;
          state.tokenVersion = action.payload.tokenVersion;
          state.lastActivity = Date.now();
        }
      });
  },
});

export const { setUser, clearError, updateLastActivity } = authSlice.actions;

export default authSlice.reducer;





.env
MONGO_URL=mongodb+srv://pick-O-cart-Mern:Jagadamba89@pick-o-cart-mern.gxyjo.mongodb.net/?retryWrites=true&w=majority
SERVER_PORT=9000
# FRONTEND_URL=https://pick-o-cart.com in production mode
FRONTEND_URL=http://localhost:5173  
USER_SECRET_KEY=PICK_O_CART_USER
ADMIN_SECRET_KEY=PICK_O_CART_ADMIN
JWT_EXPIRATION_TIME=10m
# NODE_ENV=production 
NODE_ENV=development
# REDIS_URL=
#COOKIE_DOMAIN=pick-o-cart.com in production mode
COOKIE_DOMAIN=localhost